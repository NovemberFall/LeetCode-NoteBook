## 827. Making A Large Island
![](img/2025-05-08-17-56-21.png)
---

- [youtube](https://youtu.be/pq61VNqXGvA?t=634)
---

```py
class Solution:
    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    def largestIsland(self, grid: List[List[int]]) -> int:
        self.N = len(grid)

        # 1. Precompute areas:
        size = defaultdict(int)  # island label -> size
        label = 2  # Start labeling from 2 to avoid confusion with 0 and 1
        res = 0

        for r in range(self.N):
            for c in range(self.N):
                if grid[r][c] == 1:
                    size[label] = self.dfs(r, c, grid, label)
                    label += 1

        # 2. Try flipping each 0 to 1 and calculate connected island size
        res = 0 if not size else max(size.values())
        for r in range(self.N):
            for c in range(self.N):
                if grid[r][c] == 0:
                    res = max(res, self.connect(r, c, grid, size))
        return res

    def connect(self, r, c, grid, size):
        visited = set()
        area = 1  # start with the flipped cell
        for dx, dy in self.dirs:
            nr = r + dx
            nc = c + dy
            # OR: grid[r][c] != 1
            if not self.out_of_bounds(nr, nc) and grid[nr][nc] not in visited:
                area += size[grid[nr][nc]]
                visited.add(grid[nr][nc])
        return area

    def out_of_bounds(self, r, c):
        return r < 0 or r >= self.N or c < 0 or c >= self.N

    def dfs(self, r, c, grid, label) -> int:
        if (self.out_of_bounds(r, c) or grid[r][c] == 0 or grid[r][c] == label):
            return 0
        grid[r][c] = label
        size = 1
        for dx, dy in self.dirs:
            nr = r + dx
            nc = c + dy
            size += self.dfs(nr, nc, grid, label)
        return size
```